1. Line 126 in ~/cs161/os161/kern/arch/mips/locore/trap.c describes the function (mips_trap) that gets run when a trap occurs. This is the first line of c code that gets executed. However before this happens the code starting on line 107 in ~/cs161/os161/kern/arch/mips/locore/exception-mips1.S gets run in order to save the state of the system. mips_trap only gets called in the assembly code described in this file.

In mips_trap, the following flow of executing gets decided based on the type of trap:
    If it's an interrupt, then control gets transferred to the mainbus_interrupt function, described in ~/cs161/os161/kern/include/mainbus.h and ~/cs161/os161/kern/arch/sys161/dev/lamebus_machdep.c
    If it's a system call, then control gets transferred to the syscall function described in ~/cs161/os161/kern/arch/mips/syscall/syscall.c and ~/cs161/os161/kern/include/syscall.h
    If it's a VM fault, then control gets transferred to the vm_fault function described in ~/cs161/os161/kern/arch/mips/vm/dumbvm.c and ~/cs161/os161/kern/include/vm.h
    If it's a fatal fault, then the current thread is killed by the kill_curthread function, which is also described in the ~/cs161/os161/kern/arch/mips/locore/trap.c file.

2. When a system call is defined, then a piece of MIPS assembly code (userland/lib/libc/arch/mips/syscalls.S) gets generated by the script in userland/lib/libc/syscalls/gensyscalls.sh based on the template provided by userland/lib/libc/arch/mips/mips-syscalls.S. In that file the actual line of code that triggers the trap is on line 84.


3. The files in userland provide the user interface for the libc functions. The files in the common part provide the actual implementation of the functions.

4. The configuration file configures for example the optimization level used for compiling the OS and where the OS directory is at. Changing the host OS that the code is being run on might require you to reconfigure.

5. For example functions that rely on machine specific assembly code instructions. A good example of this is found in kern/arch/mips/include/spinlock.h . The spinlock_data_testandset function is machine specific, because it relies on underlying atomic MIPS specific assembly instructions to make sure that the entire operation remains atomic. It is generally a good idea to keep this separation, because it makes it easier to port the OS to a different machine. Let's say we decided to make a pact with Cthulut and port OS161 to an x86 system. Then we would only need to change the machine specific portions of the OS to make it run on x86.

6. The trapframe gets built in kern/arch/mips/locore/exception-mips1.S in the common exception code (starting on line 106. At a very high level, the code crosses domains from userland to the kernel, finds and moves the stack pointer appropriately and then saves the current state of the processor (the old SP, PC and other registers) on the kernel stack in a trapframe, which is then used when handling the trap and finally when restoring the process state.

7.
    7.1: b,c,d
    7.2: c,d 
    7.3: a,b,c,d
    7.4: d
    7.5: None


8. The preprocessor hackery optimizes the usage of the array structure by keeping the code describing arrays close to where it is used. I would use array.h, when I need an array in critical sections in the kernal, that benefit from the optimization. The datastructure decalred in it also has a nice interface that provides a lot of protection from indexing beyond the lenght of the array and such thanks to numerous asserts. As such it would come in handy in critical portions of kernel code where extra security is called for..

9. The value is saved in the s0 and a0 registers.

10. I would have to do the following changes:
    in kern/include/syscall.h, I have to add a prototype for the system call.
    In kern/include/kern/syscall.h, I have to make sure the system call has a number. If not, add / uncomment it.
    In kern/arch/mips/syscall/syscall.c, I have to implement the system call handler for that system call.
    Finally, I have to re-run step d from question 7.

11.
    In start.S, a boot stack gets set up and the status register gets set.
    Then in kmain the boot function gets called, which bootstraps (connects) the hardware (RAM, mainbus, etc) as well as allocates data structures for processes, a virtual filesystem, threads, sets up a wait channel for a harware clock. It also prepares the kernel's heap memeory. Then software-only devices are configured. Then virtual memory gets bootstrapped. Then secondary CPUs are started. Finally the virtual file systems buffers are initialized and the virtual filesystems' boot file system is set to "emu0". After all this is done, we reach menu.


12. In order to put a thread to sleep, wchan_sleep must be called on a waitchannel and spinlock. This function in turn does some asserts and finally does calls the thread_switch function with the newstate being S_SLEEP and passing in the given waitchannel and spinlock.

The Thread_switch function then does the following:
    - Interrupts are turned off
    - The CPUs runqueue is locked
    - The thread is added to the list of the given waitchannel and the spinlock is released.
    - Finally the cpu is marked as idle

Now that all that has been done, the cpu is given a new thread to handle


13. Context switching is handled by the thread_switch function, which in turn calls switchframe_switch and some other helper functions such as as_activate and exorcise.

14. When interrupts are turned off, then the current priority level is set to high. This means that the CPU will not accept any interrupts and will continue executing the current line of code until the interupts are turned back on and one happens. It is important to turn interupts off in the thread subsystem code, because in that code, you are in the middle of changing the state of a thread, creating a new thread, deleting an old one or already swapping to another thread. If during these operations an interupt happens and the CPU would try to do another context switch, then the state of threads would get jumbled up.

15. When a thread wakes up another thread, then it is removed from the threadlist associated with the waitchannel that made it sleep. Once it is removed, the state of the thread is set to S_READY and it is put on a CPUs runqueue. For the thread to actually run, it must be taken off the CPUs runqueue. This might happen for example if the thread_switch function gets called.

16. Whenever the hardware timer interrupt happens, then the schedule function gets called, which should reshuggle the current CPU's run queue by job priority. Not sure if this would be considered to be hardware independent, but the thread_consider_migration function also gets called on hardware timer interrupts. This function considers migrating a thread from one CPU to another for optimization.

17. Eeach semaphore comes with it's own wait channel and spinlock. When a semaphore is created, it has some initial count on it. Whenever a thread wants to use the semaphore protected resource, it calls the P function. As long as the semaphore count is greater than 0, then the thread is let right through and the count gets decremented. Now however when the count is at 0 and a thread calls P, then whcan_sleep is used to put the thread to sleep using the semaphore's wait channel. Now when a thread finishes using the protected resource, that thread must call the V function. The V function atomically increments the count and then uses whcan_wakeone to wake up one of the threads that had been waiting on the semaphore in the P function.

18. lock_do_i_hold is a necesrary function, because a thread must sometimes know whether it has previously already aquired a lock. However in order to maintain isolation, a thread should not need to know who holds a lock. When the holding thread is finished with the lock, it will release it. An outside thread should never attempt to do anything with a lock while it is being held, so there's no reason for it to know who holds it.
    
Unit tests:

Locks:

A properly implemented lock will:
    1. after being successfully created, have
        - lk_name equal to passed in name
        - lk_name does not point to the same place in memory as passed in name
        - lk_wchan is not NULL
        - lk_holder will be NULL
        - lk_splk is not held and has no owner
    2. return true when a thread that holds it calls lock_do_i_hold
    3. return false when a thread that does not hold it calls lock_do_i_hold
    4. not let a thread other than the one that holds it release it
    5. put a thread that is trying to acquire it to sleep if it is already acquired by another thread
    

CVs:

A properly implemented cv will:
    1. after being successfully created, have
        - cv_name equal to passed in name
        - cv_name does not point to the same place in memory as passed in name
        - cv_wchan is not NULL
        - cv_lock is not held and has no owner
    2. put a thread to sleep when it calls cv_wait
    3. wake exactly one thread up when a thread calls cv_signal
    4. wake up all threads when a thread class cv_broadcast
    5. not let a thread call cv_signal, if it does not hold the associated lock
    6. not let a thread call cv_broadcast if it does not hold the associated lock.
    7. not let a thread call cv_wait if it does not hold the associated lock.
